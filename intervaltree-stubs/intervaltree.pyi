from collections.abc import MutableSet, Iterable, Callable, Iterator
from typing import TypeVar, Generic
from numbers import Real
from .interval import Interval
from .node import Node
from sortedcontainers import SortedDict  # type: ignore

T = TypeVar("T")
N = TypeVar("N", int, float, Real)

class IntervalTree(MutableSet[T], Generic[N, T]):
    all_intervals: list[Interval[N, T]] | None
    top_node: Node[N, T]
    boundary_table: SortedDict
    @classmethod
    def from_tuples(cls, tups: tuple[N, N] | tuple[N, N, T]) -> IntervalTree[N, T]: ...
    def __init__(self, intervals: list[Interval[N, T]] | None = None) -> None: ...
    def copy(self) -> IntervalTree[N, T]: ...
    def _add_boundaries(self, interval: Interval[N, T]) -> None: ...
    def _remove_boundaries(self, interval: Interval[N, T]) -> None: ...
    def add(self, interval: Interval[N, T]) -> None: ...
    def append(self, interval: Interval[N, T]) -> None: ...
    def addi(self, begin: N, end: N, data: T | None = None) -> None: ...
    def appendi(self, begin: N, end: N, data: T | None = None) -> None: ...
    def update(self, intervals: Iterable[Interval[N, T]]) -> None: ...
    def remove(self, interval: Interval[N, T]) -> None: ...
    def removei(self, begin: N, end: N, data: T | None = None) -> None: ...
    def discard(self, interval: Interval[N, T]) -> None: ...
    def discardi(self, begin: N, end: N, data: T | None = None) -> None: ...
    def difference(self, other: IntervalTree[N, T]) -> IntervalTree[N, T]: ...
    def difference_update(self, other: IntervalTree[N, T]) -> None: ...
    def union(self, other: IntervalTree[N, T]) -> IntervalTree[N, T]: ...
    def intersection(self, other: IntervalTree[N, T]) -> IntervalTree[N, T]: ...
    def intersection_update(self, other: IntervalTree[N, T]) -> None: ...
    def symmetric_difference(self, other: IntervalTree[N, T]) -> IntervalTree[N, T]: ...
    def symmetric_difference_update(self, other: IntervalTree[N, T]) -> None: ...
    def remove_overlap(self, begin: N, end: N | None = None) -> None: ...
    def remove_envelop(self, begin: N, end: N) -> None: ...
    def chop(self, begin: N, end: N, datafunc: Callable[[Interval[N, T], bool], T] | None = None) -> None: ...
    def slice(self, point: N, datafunc: Callable[[Interval[N, T], bool], T] | None = None) -> None: ...
    def clear(self) -> None: ...
    def find_nested(self) -> dict[Interval[N, T], set[Interval[N, T]]]: ...
    def overlaps(self, begin: N, end: N | None = None) -> bool: ...
    def overlaps_point(self, p: N) -> bool: ...
    def overlaps_range(self, begin: N, end: N) -> bool: ...
    def split_overlaps(self) -> None: ...
    def merge_overlaps(
        self, data_reducer: Callable[[T, T], T] | None = None, data_initializer: T | None = None, strict: bool = True
    ) -> None: ...
    def merge_equals(
        self, data_reducer: Callable[[T, T], T] | None = None, data_initializer: T | None = None
    ) -> None: ...
    def items(self) -> set[Interval[N, T]]: ...
    def is_empty(self) -> bool: ...
    def at(self, p: N) -> set[Interval[N, T]]: ...
    def envelop(self, begin: N, end: N | None = None) -> set[Interval[N, T]]: ...
    def overlap(self, begin: N, end: N | None = None) -> set[Interval[N, T]]: ...
    def begin(self) -> N: ...
    def end(self) -> N: ...
    def range(self) -> Interval[N, None]: ...
    def span(self) -> N: ...
    def print_structure(self, tostring: bool = False) -> None | str: ...
    def verify(self) -> None: ...
    def score(self, full_report: bool = False) -> float: ...
    def __getitem__(self, index: int) -> Interval[N, T]: ...
    def __setitem__(self, index: int, value: Interval[N, T]) -> None: ...
    def __delitem__(self, point: N) -> None: ...
    def __contains__(self, item: Interval[N, T]) -> bool: ...
    def containsi(self, begin: N, end: N, data: T | None = None) -> bool: ...
    def __iter__(self) -> Iterator[Interval[N, T]]: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: IntervalTree[N, T]) -> bool: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __reduce__(self) -> tuple[type[IntervalTree[N, T]], tuple[list[Interval[N, T]]]]: ...
