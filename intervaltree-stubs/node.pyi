from typing import SupportsFloat, Generic, TypeVar
from collections.abc import Sequence
from typing_extensions import SupportsIndex
from .interval import Interval
from numbers import Real

T = TypeVar("T")
N = TypeVar("N", int, float, Real)

def l2(num: SupportsFloat | SupportsIndex) -> SupportsFloat | SupportsIndex: ...

class Node(Generic[N, T], object):
    def __init__(
        self,
        x_center: Interval[N, T] | None = None,
        s_center: set[Interval[N, T]] = set(),
        left_node: Node[N, T] | None = None,
        right_node: Node[N, T] | None = None,
    ) -> None: ...
    @classmethod
    def from_interval(cls, interval: Interval[N, T]) -> Node[N, T]: ...
    @classmethod
    def from_intervals(cls, intervals: Sequence[Interval[N, T]]) -> Node[N, T]: ...
    def init_from_sorted(self, intervals: Sequence[Interval[N, T]]) -> Node[N, T]: ...
    def center_hit(self, interval: Interval[N, T]) -> bool: ...
    def hit_branch(self, interval: Interval[N, T]) -> bool: ...
    def refresh_balance(self) -> None: ...
    def compute_depth(self) -> int: ...
    def rotate(self) -> Node[N, T]: ...
    def srotate(self) -> Node[N, T]: ...
    def drotate(self) -> Node[N, T]: ...
    def add(self, interval: Interval[N, T]) -> Node[N, T]: ...
    def remove(self, interval: Interval[N, T]) -> Node[N, T]: ...
    def discard(self, interval: Interval[N, T]) -> Node[N, T]: ...
    def remove_interval_helper(
        self, interval: Interval[N, T], done: list[int], should_raise_error: bool
    ) -> Node[N, T]: ...
    def search_overlap(self, point_list: list[N]) -> set[Interval[N, T]]: ...
    def search_point(self, point: N, result: set[Interval[N, T]]) -> set[Interval[N, T]]: ...
    def prune(self) -> Node[N, T]: ...
    def pop_greatest_child(self) -> tuple[Node[N, T], Node[N, T]]: ...
    def contains_point(self, p: N) -> bool: ...
    def all_children(self) -> set[Interval[N, T]]: ...
    def all_children_helper(self, result: set[Interval[N, T]]) -> set[Interval[N, T]]: ...
    def verify(self, parents: set[Interval[N, T]]) -> None: ...
    def __getitem__(self, index: int) -> Node[N, T]: ...
    def __setitem__(self, key: int, value: Node[N, T]) -> None: ...
    def __str__(self) -> str: ...
    def count_nodes(self) -> int: ...
    def depth_score(self, n: SupportsFloat | SupportsIndex, m: SupportsFloat | SupportsIndex) -> float: ...
    def depth_score_helper(self, d: int, dopt: float) -> float: ...
    def print_structure(self, indent: int = 0, tostring: bool = False) -> str | None: ...
